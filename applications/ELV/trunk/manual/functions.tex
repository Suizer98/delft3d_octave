\subsection{ELV.m}
ELV is the main function of the model \\ 
 \\ 
ELV(path\_file\_input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -path\_file\_input = path to the file input.mat; $[$char$]$;  \\ 
	-fid\_log = log file identifier \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{ELV\_version.m}
ELV\_version is a function that writes the version of each function in the log file \\ 
 \\ 
ELV\_version(fid\_log) \\ 
 \\ 
INPUT: \\ 
   -fid\_log = file identifier \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{active\_layer\_mass\_update.m}
active\_layer\_mass\_update updates the mass (volume) of sediment at the active layer. \\ 
 \\ 
\texttt{Mak\_new=active\_layer\_mass\_update(Mak,detaLa,fIk,qbk,bc,input,fid\_log,kt)} \\ 
 \\ 
INPUT: \\ 
   -\texttt{Mak} = effective volume of sediment per unit of bed area in the active layer $[$m$]$; $[$(nf-1)x(nx) double$]$ \\ 
   -\texttt{detaLa} = variation in elevation of the interface between the active layer and the substarte $[$m$]$; $[$(1)x(nx) double$]$ \\ 
   -\texttt{fIk} = effective volume fraction content of sediment at the interface between the active layer and the substrate $[$-$]$; $[$(nf-1)x(nx) double$]$ \\ 
   -\texttt{qbk} = volume of sediment transported excluding pores per unit time and width and per size fraction $[$m$^2$/s$]$; $[$(nf)x(nx) double$]$ \\ 
   -\texttt{bc} = boundary conditions structure  \\ 
   -\texttt{input} = input structure \\ 
   -\texttt{fid\_log} = identificator of the log file \\ 
   -\texttt{kt} = time step counter $[$-$]$; $[$(1)x(1) double$]$ \\ 
 \\ 
OUTPUT: \\ 
   -\texttt{Mak\_new} = new effective volume of sediment per unit of bed area in the active layer $[$m$]$; $[$(nf-1)x(nx) double$]$ \\ 
 \\ 
\subsection{active\_layer\_mass\_update\_pmm.m}
function\_name does this and that \\ 
 \\ 
Mak\_new=active\_layer\_mass\_update\_pmm(Mak,detaLa,fIk,qbk,bc,pmm,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{active\_layer\_thickness\_update.m}
active\_layer\_thickness\_update is a function that updates the active layer thickness \\ 
 \\ 
La=active\_layer\_thickness\_update(h,Mak,La\_old,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{add\_nourishment.m}
add\_nourishment modifies the bed adding nourished sediment \\ 
 \\ 
$[$Mak\_new,msk\_new,Ls\_new,La\_new,etab\_new,h\_new$]$=add\_nourishment(Mak\_old,msk\_old,Ls\_old,La\_old,etab\_old,h\_old,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{add\_sedflags.m}
add\_sedflags parse the sediment input and adds the sediment transport relation flags to the input structure  \\ 
 \\ 
input=add\_sedflags(input) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   -input = input structure \\ 
 \\ 
\subsection{analytical\_cubic\_root.m}
analytical\_cubic\_root returns the three roots of a cubic polynomial, provided they are real. \\ 
 \\ 
root=analytical\_cubic\_root(a\_coeff, b\_coeff, c\_coeff, d\_coeff) \\ 
 \\ 
INPUT: \\ 
   -a\_coeff = a coefficient of the polynomial \\ 
   -b\_coeff = b coefficient of the polynomial \\ 
   -c\_coeff = c coefficient of the polynomial \\ 
   -d\_coeff = d coefficient of the polynomial \\ 
 \\ 
OUTPUT: \\ 
   -root = three roots \\ 
 \\ 
\subsection{aux\_ini\_normalflow.m}
aux\_ini\_normalflow is an auxiliary function that returns the difference between the boundary condition values of q and qbk and the computed ones \\ 
 \\ 
F=aux\_ini\_normalflow(X,objective,flg,cnt,cf,La,dk,sed\_trans\_param,hiding\_param,mor\_fac) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   -a .bcm compatible with D3D is created in file\_name \\ 
 \\ 
\subsection{aux\_swc.m}
aux\_swc is an auxiliary function of side\_wall\_corection \\ 
 \\ 
F=aux\_swc(X,u,Sf,input) \\ 
 \\ 
INPUT: \\ 
	-X =  \\ 
	-u =  \\ 
	-Sf = \\ 
   -input =  \\ 
 \\ 
OUTPUT: \\ 
   -F =  \\ 
 \\ 
\subsection{backwater.m}
backwater does this and that \\ 
 \\ 
$[$U,H$]$=backwater(ib,Cf,Hdown,Q,input) \\ 
 \\ 
INPUT: \\ 
   -ib = slope vector \\ 
   -Cf = dimensionless representative friction \\ 
   -Q = upstream discharge (constant), or a discharge vector; \\ 
 \\ 
OUTPUT: \\ 
   -U =  \\ 
   -H =  \\ 
 \\ 
\subsection{backwater\_step.m}
backwater\_step computes just one step of the solver u,h,etab,Cf should be single values; \\ 
 \\ 
$[$U,H$]$=backwater\_step(x,h,ib,Cf,Q,input) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{bed\_level\_update.m}
bed\_level\_update updates the bed elevation \\ 
 \\ 
etab\_new=bed\_level\_update(etab,qbk,bc,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{bed\_level\_update\_pmm.m}
bed\_level\_update\_pmm updates the bed elevationconsidering PMM \\ 
 \\ 
etab\_new=bed\_level\_update\_pmm(etab,qbk,bc,pmm,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{beta\_pmm.m}
beta\_pmm computes the value of beta such that the eigenvalues of the modified matrix A have the same value of than in the original system matrix. \\ 
 \\ 
beta\_o=beta\_pmm(A,alpha\_i,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{boundary\_conditions\_construction.m}
boundary\_condition\_construction is a function that interpolates the boundary conditions \\ 
 \\ 
bc=boundary\_conditions\_construction(u,h,Mak,La,Cf,input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   -bc = boundary conditions $[$struct$]$  \\ 
 \\ 
\subsection{check\_input.m}
check\_input is a function that checks that the input is enough and makes sense \\ 
 \\ 
input\_out=check\_input(input,path\_file\_input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
\subsection{check\_simulation.m}
check\_simulation does this and that \\ 
 \\ 
check\_simulation(u,h,Mak,Mak\_old,msk,msk\_old,La,La\_old,Ls,Ls\_old,qbk,bc,ell\_idx,celerities,pmm,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{compare\_results.m}
compare\_results compares 2 output file. 0 means they are the same \\ 
 \\ 
$[$equal\_bol\_t,equal\_bol,dif\_idx,dif\_res,dif\_max$]$=compare\_results(output\_ref,output\_chk,var) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{condition\_construction.m}
condition\_construction does this and that \\ 
 \\ 
$[$u,h,etab,Mak,La,msk,Ls,Cf,bc$]$ = condition\_construction (input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
   -fid\_log = identificator of the log file \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{derivatives.m}
function\_name does this and that \\ 
 \\ 
$[$dqb\_dq,dqbk\_dq,dqb\_dMal,dqbk\_dMal$]$=derivatives(u,h,Cf,La,qbk,Mak,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{display\_tloop.m}
display\_tloop is a function that displays in command at the end of every time step \\ 
 \\ 
display\_tloop(time\_loop,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{dv\_bouss\_coef.m}
dv\_bouss\_coef does this and that \\ 
 \\ 
$[$a1, a2$]$ = dv\_bouss\_coef(input,x,h) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{dv\_cross\_aux.m}
dv\_cross\_aux does this and that \\ 
 \\ 
diff = dv\_cross\_aux(input, x, term) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{dv\_cross\_section.m}
dv\_cross\_section compute the coefficient resulting from the derivative of the cross section: \\ 
  dAf/dx = a1*(dh/dx) + a2(h) \\ 
The computation is performed in different parts for the main channel and flood planes seperately. \\ 
 \\ 
$[$a1, a2, I\_a1, I\_a2, II\_a1, II\_a2, III\_a1, III\_a2$]$ = dv\_cross\_section(input,x,hh,variable) \\ 
 \\ 
INPUT: \\ 
   -x = should be a node identifier \\ 
   -h = vector with h(1,x) the location at x! \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{eli\_1.m}
eli\_1 does this and that \\ 
 \\ 
La\_new=eli\_1(La,ell\_idx,in\_f,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{elliptic\_nodes.m}
elliptic\_nodes does this and that \\ 
 \\ 
$[$ell\_idx,out$]$=elliptic\_nodes(u,h,Cf,La,qbk,Mak,fIk,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{errorprint.m}
errorprint is a function that prints in the log file the error catched \\ 
 \\ 
errorprint(error\_obj,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{flow\_update.m}
flow\_update updates the flow depth and the mean flow velocity. \\ 
 \\ 
$[$u\_new,h\_new$]$=flow\_update(u,h,etab,Cf,bc,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{folders\_creation.m}
folders\_creation is a function that created the folder where output may be stored. \\ 
 \\ 
folders\_creation(path\_file\_input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{friction.m}
friction is a function that computed the dimensionless friction coefficient \\ 
 \\ 
Cf=friction(h,Mak,Cf\_old,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{friction\_correction.m}
friction\_correction corrects the friction coefficient for wall friction and ripples \\ 
 \\ 
$[$Cf\_b$]$=friction\_correction(u,h,Cf,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{function\_layout.m}
function\_name does this and that \\ 
 \\ 
\texttt{$[$output$]$=function\_name(input)} \\ 
 \\ 
INPUT: \\ 
   -\texttt{input} = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   -\texttt{output} = variable containing the output $[$struct$]$ e.g. input \\ 
 \\ 
\subsection{get\_analytical\_solution.m}
get\_analytical\_solution does this and that \\ 
 \\ 
get\_analytical\_solution(folder\_run) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_bouss\_coef.m}
get\_bouss\_coef does this and that \\ 
 \\ 
alpha\_b = get\_bouss\_coef(input,x,hh) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_cross\_section.m}
get\_cross\_section does this and that \\ 
 \\ 
$[$T,I,II,III$]$ = get\_cross\_section(input,x,h,variable) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_equislope.m}
get\_equislope does this and that \\ 
 \\ 
S = get\_equislope(Qw,input,AL,Fk,X0) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_equivals.m}
get\_equivals computes the normal load distribution given a hydrograph and the annual load \\ 
 \\ 
$[$S,Fk$]$ = get\_equivals(Qw,input,AL,sedp,X0) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_equivals2\_pdf.m}
get\_equivals2\_pdf does this and that \\ 
 \\ 
$[$B,Fk$]$ = get\_equivals2\_pdf(pq,dq,input,AL,sedp,S,X0) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_equivals\_V.m}
get\_equivals\_V is a slight modification of get\_equivals to not display output \\ 
 \\ 
$[$S0,Fak0,sum\_Fak\_obj,max\_rel\_error$]$ = get\_equivals\_V(Qw,input\_1,AL,sedp\_1) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_equivals\_pdf.m}
get\_equivals\_pdf does this and that \\ 
 \\ 
$[$S,Fk$]$ = get\_equivals\_pdf(pq,dq,input,AL,sedp,X0) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_flow\_velocities.m}
get\_flow\_velocities does this and that \\ 
 \\ 
U = get\_flow\_velocities(input,x,Q,h,ib) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_rep\_fric.m}
get\_rep\_fric does this and that \\ 
 \\ 
Cf\_rep = get\_rep\_fric(input,x,h) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{get\_sedigraph.m}
get\_sedigraph does this and that \\ 
 \\ 
Qb = get\_sedigraph(Qw,input,S,Fk) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{grain\_size\_distribution\_update.m}
grain\_size\_distribution\_update updates the mass at the active layer and the substrate and the substrate thickness \\ 
 \\ 
$[$Mak\_new,msk\_new,Ls\_new,La\_ne,etab\_new,ell\_idx,out\_en,pmm$]$=grain\_size\_distribution\_update(Mak,msk,Ls,La\_old,La,etab\_old,etab,qbk,bc,u,h,Cf,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{ini\_Cf.m}
ini\_Cf is a function that creates the initial friction coefficient vector \\ 
 \\ 
Cf=ini\_Cf(input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{ini\_La.m}
ini\_La this function creates the initial active layer thickness vector \\ 
 \\ 
La=ini\_La(input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{ini\_msk.m}
ini\_msk is a function that creates the substrate variable \\ 
 \\ 
$[$msk,Ls$]$=ini\_msk(La,input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{ini\_normalflow.m}
ini\_normalflow is a function that finds the normal flow conditions at the first time step.  \\ 
 \\ 
$[$u,h,slopeb,Fak$]$=ini\_normalflow(input,Cf,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{ini\_normalflow\_L.m}
ini\_normalflow\_L is a function that finds the normal flow conditions at the first time step.  \\ 
 \\ 
$[$u,h,slopeb,Fak$]$=ini\_normalflow\_L(input,Cf,fid\_log) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{ini\_spacem.m}
ini\_spacem approximates the alternating steady equilibrium profile using the space marching algorithm \\ 
 \\ 
$[$u,h,etab,qb,Fak$]$ = ini\_spacem(input,fid\_log,bc) \\ 
 \\ 
INPUT: \\ 
   -input: general ELV input file; \\ 
       input.ini.initype:  12 alternating steady, return mean condition \\ 
                           13 alternating steady + time reconstrcution, \\ 
                           return first condition \\ 
                           14 do not use in combination with ELV \\ 
       input.ini.initype:  5- space marching model + time reconstruction, \\ 
                           return the first condition as initial condition \\ 
                           51=12 - space marching, return mean condition \\ 
                           52 = 5 =13 \\ 
                           53 = 15 =parstudy settings, loading, (dq,pq) from \\ 
                           file \\ 
                            \\ 
   -fid\_log: variable for log-file, may be empty \\ 
   -bc: struct consisting of the boundary conditions \\ 
           -bc.q0 \\ 
           -bc.qbk \\ 
           -bc.etaw0 \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{initial\_condition\_construction.m}
initial\_condition\_construction does this and that \\ 
 \\ 
$[$u,h,etab,Mak,La,msk,Ls,Cf$]$=initial\_condition\_construction(input,fid\_log,bc) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{join\_results.m}
join\_results does this and that \\ 
 \\ 
join\_results(input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{log\_file\_creation.m}
log\_file\_creation is a function that creates the log file \\ 
 \\ 
fid\_log=log\_file\_creation(path\_file\_input) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{output\_creation.m}
output\_creation is a function that creates the file where the results will be saved and saves the initial condition. \\ 
 \\ 
output\_creation(input,fid\_log) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{phi\_func.m}
phi\_func does this and that \\ 
 \\ 
phi = phi\_func(theta, input) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{preconditioning\_mass\_matrix.m}
preconditioning\_mass\_matrix does this and that \\ 
 \\ 
pmm=preconditioning\_mass\_matrix(ell\_idx,out\_en,u,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{preissmann.m}
preissmann is the Preismmann scheme for unsteady flow update Implict scheme \\ 
 \\ 
$[$U,H$]$ = preissmann(u,h,etab,Cf,Hdown,qwup,input,fid\_log,kt) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{print\_tloop.m}
print\_tloop is a function that print in the log file the time to finish \\ 
 \\ 
print\_tloop(time\_loop,input,fid\_log,kt,kts) \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{run\_ELV.m}
run\_ELV is a function that creates the folders for the output, calls the main function and then the postprocessing functions \\ 
 \\ 
run\_ELV(path\_file\_input) \\ 
 \\ 
INPUT: \\ 
   -path\_file\_input = path to the file input.mat; $[$char$]$; \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{run\_spacemarching.m}
run\_ELV is a function that creates the folders for the output, calls the main function and then the postprocessing functions \\ 
 \\ 
run\_spacemarching(path\_file\_input) \\ 
 \\ 
INPUT: \\ 
   -path\_file\_input = path to the file input.mat; $[$char$]$; \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{sediment\_transport.m}
sediment transport calculation  \\ 
 \\ 
$[$qbk,Qbk$]$=sediment\_transport(flg,cnt,h,q,cf,La,Mak,dk,sed\_trans\_param,hiding\_param,mor\_fac,fid\_log,kt) \\ 
 \\ 
% INPUT \\ 
Symbols used in the size definition: \\ 
   %-nx is the number of points in streamwise directions \\ 
   %-nf is the number of size fractions \\ 
    \\ 
   % flg = flags ; structure \\ 
       % flg.sed\_trans = sediment transport relation \\ 
           % 1 = Meyer-Peter, Muller (1948)     \\ 
           % 2 = Engelund-Hansen (1967) \\ 
           % 3 = Ashida-Michiue (1972) \\ 
           % 4 = Wilcock-Crowe (2003) \\ 
       % flg.friction\_closure = friction closure relation \\ 
           % 1 = Chezy | Darcy-Weisbach \\ 
           % 2 = Manning  \\ 
       % flg.hiding = hiding-exposure effects \\ 
           % 0 = no hiding-exposure  \\ 
           % 1 = Egiazaroff (1965) \\ 
           % 2 = Power law \\ 
           % 3 = Ashida-Michiue (1972) \\ 
       % flg.Dm = mean grain size \\ 
           % 1 = geometric \\ 
           % 2 = arithmetic  \\ 
   % cnt = constans ; structure \\ 
       % cnt.g         = gravity $[$m$^2$/s$]$ ; double $[$1,1$]$ \\ 
       % cnt.rho\_s     = sediment density $[$kg/m$^3$$]$ ; double $[$1,1$]$ \\ 
       % cnt.rho\_w     = water density $[$kg/m$^3$$]$ ; double $[$1,1$]$ \\ 
       % cnt.p         = porosity $[$-$]$ ; double $[$1,1$]$ \\ 
   % h               = flow depth $[$m$]$ ; double $[$nx,1$]$ | double $[$1,nx$]$ ; e.g. $[$0.5,0.1,0.6$]$; \\ 
   % q               = specific water discharge $[$m$^2$/s$]$ ; double $[$nx,1$]$ | double $[$1,nx$]$ ; e.g. $[$5;2;2$]$; \\ 
   % cf              = dimensionless friction coefficient (u\_{*}^{2}=cf*u$^2$) $[$-$]$ ; double $[$nx,1$]$ | double $[$1,nx$]$ ; e.g. $[$0.011,0.011,0.011$]$; \\ 
   % La              = active layer thickness $[$m$]$ ; double $[$nx,1$]$ | double $[$1,nx$]$ ; e.g. $[$0.01,0.015,0.017$]$; \\ 
   % Mak             = effective mass matrix ; double $[$nx,nf-1$]$ ; e.g. $[$0.2,0.3;0.8,0.1;0.9,0$]$ ; \\ 
   % dk              = characteristic grain sizes $[$m$]$ ; double $[$1,nf$]$ | double $[$nf,1$]$ ; e.g. $[$0.003,0.005$]$ \\ 
   % sed\_trans\_param = parameters of the sediment transport relation choosen  \\ 
           % MPM48    = $[$a\_mpm,b\_mpm,theta\_c$]$ $[$-,-,-$]$ ; double $[$3,1$]$ | double $[$1,3$]$; original = $[$8,1.5,0.047$]$ \\ 
           % EH67     = $[$m\_eh,n\_eh$]$ ; $[$s^4/m$^3$,-$]$ ; double $[$2,1$]$ | double $[$1,2$]$ ; original = $[$0.05,5$]$ \\ 
           % AM72     = $[$a\_am,theta\_c$]$ $[$-,-$]$ ; double $[$2,1$]$ | double $[$1,2$]$ ; original = $[$17,0.05$]$ \\ 
           % GL       = $[$r,w,tau\_ref$]$ \\ 
   % hiding\_param    = parameter of the power law hiding function $[$-$]$ ; double $[$1,1$]$ ; e.g. $[$-0.8$]$ \\ 
   % mor\_fac         = morphological acceleration factor $[$-$]$ ; double $[$1,1$]$ ; e.g. $[$10$]$ \\ 
        \\ 
% OUTPUT \\ 
   % qbk = sediment transport per grain size and node including pores and morphodynamic acceleration factor $[$m$^2$/s$]$ ; double $[$nx,nf$]$ \\ 
   % Qbk = sediment transport capacity per grain size and node including pores and morphodynamic acceleration factor $[$m$^2$/s$]$ ; double $[$nx,nf$]$ \\ 
   \\ 
% NOTES \\ 
   %-The morphodynamic accelerator factor is included in the sediment \\ 
   % transport relations. If you want to compute is outside, set it equal \\ 
   % to 1.  \\ 
   %-The porosity is included in the sediment transport relations. If you \\ 
   % want to copute it without pores, set it equal to 0. \\ 
   %-In the Hirano model, 'mass' (Mak) refers to the product of the volume \\ 
   % fractions per the active layer thickness (Mak=La*Fak). It is done in \\ 
   % this way to be able to easily calculate the derivatives respect to \\ 
   % the mass, which is what matters.  \\ 
   %-The terms 'effective' refers to nf-1 fractions. It is done in this \\ 
   % minimize mass issues and to be able to compute the derivatives respect \\ 
   % to mass.  \\ 
   %-It is thought as a 1D computation of a multi-fraction mixture in the \\ 
   % Hirano model. You can compute unisize transport by setting La equal to \\ 
   % 1 and Mak equal to an empty matrix. \\ 
   %-All input needs to be specified. The parse needs to be before the \\ 
   % function calling. This is done in this way because parameters (e.g. \\ 
   % gravity) are used outside the sediment transport. This means that \\ 
   % before calling this function there needs to be a parse and a check to, \\ 
   % for example, the sediment transport parameteres.  \\ 
% \\ 
\subsection{side\_wall\_correction.m}
side\_wall\_correction \\ 
 \\ 
$[$Cf\_t,Cf\_b,Cf\_w,u\_st\_b$]$=side\_wall\_correction(input\_i,u,h,Sf) \\ 
 \\ 
INPUT: \\ 
   -Mak = effective volume of sediment per unit of bed area in the active layer $[$m$]$; $[$(nf-1)x(nx) double$]$ \\ 
	-detaLa = variation in elevation of the interface between the active layer and the substarte $[$m$]$; $[$(1)x(nx) double$]$ \\ 
	-fIk = effective volume fraction content of sediment at the interface between the active layer and the substrate $[$-$]$; $[$(nf-1)x(nx) double$]$ \\ 
	-qbk = volume of sediment transported excluding pores per unit time and width and per size fraction $[$m$^2$/s$]$; $[$(nf)x(nx) double$]$ \\ 
	-bc = boundary conditions structure  \\ 
	-input = input structure \\ 
	-fid\_log = identificator of the log file \\ 
	-kt = time step counter $[$-$]$; $[$(1)x(1) double$]$ \\ 
 \\ 
OUTPUT: \\ 
   -Mak\_new = new effective volume of sediment per unit of bed area in the active layer $[$m$]$; $[$(nf-1)x(nx) double$]$ \\ 
 \\ 
\subsection{slope2elevation.m}
slope2elevation computes the bed elevation given the slope \\ 
 \\ 
INPUT: \\ 
   -input = variable containing the input $[$struct$]$ e.g. input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{solve\_Hdown.m}
unction obj = solve\_Hdown(X,input,dQ,pQ,AL) \\ 
solve\_Hdown computes H\_down \\ 
 VERSION 3 \\ 
 \\ 
INPUT: \\ 
   -input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{solve\_equibed.m}
unction obj = solve\_equibed(X,H,input,dQ,pQ,AL) \\ 
solve\_Hdown computes H\_down \\ 
 VERSION 3 \\ 
 \\ 
INPUT: \\ 
   -input (ELV) \\ 
   -X: mean bed elevation \\ 
   -H: water surface elevation (element or vector) \\ 
   -dQ: vector with discharge values \\ 
   -pQ: vector with probability of occurence of discharge values \\ 
   -AL: average load per fraction \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{solve\_mixed.m}
unction obj = solve\_mixed(X,input,Fak\_old, Qbk, dQbkdu, h\_old, Fr\_old, u\_old, pq, K, AL, dxi, dq) \\ 
solve\_mixed computes an update of the space marching algorithm \\ 
 VERSION 3 \\ 
 \\ 
INPUT: \\ 
   -input \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{solve\_nfbc.m}
unction obj = solve\_nfbc(X,input,Qw,AL) \\ 
solve\_sedigraph computes the slope and surface fraction  \\ 
 VERSION 1 \\ 
 \\ 
INPUT: \\ 
   -X(1) for slope, remainder for fractions \\ 
   -input for parmaters \\ 
   -Qw: equidistant spaced hydrograph \\ 
   -AL: mean annual load per fraction \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{solve\_nfbc2\_pdf.m}
unction obj = solve\_nfbc2\_pdf(X,input,dq,pq,AL,ib) \\ 
solve\_sedigraph computes the slope and surface fraction  \\ 
 VERSION 1 \\ 
 \\ 
INPUT: \\ 
   -X(1) for slope, remainder for fractions \\ 
   -input for parmaters \\ 
   -Qw: equidistant spaced hydrograph \\ 
   -AL: mean annual load per fraction \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{solve\_nfbc\_pdf.m}
unction obj = solve\_nfbc\_pdf(X,input,dq,pq,AL) \\ 
solve\_sedigraph computes the slope and surface fraction  \\ 
 VERSION 1 \\ 
 \\ 
INPUT: \\ 
   -X(1) for slope, remainder for fractions \\ 
   -input for parmaters \\ 
   -Qw: equidistant spaced hydrograph \\ 
   -AL: mean annual load per fraction \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{solve\_qdom.m}
unction obj = solve\_qdom(X,input,ib,F,AL,k) \\ 
solve\_sedigraph computes the slope and surface fraction  \\ 
 VERSION 1 \\ 
 \\ 
INPUT: \\ 
   -X: dominant discharge \\ 
   -input for parmaters \\ 
   -ib: slope \\ 
   -F: fraction of gravel  \\ 
   -Qw: equidistant spaced hydrograph \\ 
   -AL: mean annual load per fraction \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{solve\_qdom\_pdf.m}
unction obj = solve\_qdom\_pdf(X, input,ib,F,AL,k) \\ 
solve\_sedigraph computes the slope and surface fraction  \\ 
 VERSION 1 \\ 
 \\ 
INPUT: \\ 
   -X: dominant discharge \\ 
   -input for parmaters \\ 
   -ib: slope \\ 
   -F: fraction of gravel  \\ 
   -Qw: equidistant spaced hydrograph \\ 
   -AL: mean annual load per fraction \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{substrate\_update.m}
function\_name does this and that \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{warningprint.m}
warningprint does this and that \\ 
 \\ 
warningprint(fid\_log, text) \\ 
 \\ 
INPUT: \\ 
   -input = input structure \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
\subsection{write\_results.m}
write\_results does this and that \\ 
 \\ 
write\_results(input,fid\_log,kts) \\ 
 \\ 
INPUT: \\ 
   - \\ 
 \\ 
OUTPUT: \\ 
   - \\ 
 \\ 
