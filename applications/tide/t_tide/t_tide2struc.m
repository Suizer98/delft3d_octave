function varargout = t_tide2struc(varargin)
%T_TIDE2STRUC    t_tide with structure output
%
%   [D,<fit>] = t_tide2struc(t,var,<keyword,value>)
%
% performs a t_tide tidal analysis and saves result as a struct that can 
% be written to file with t_tide2xml, t_tide2html, t_tide2nc.
% (i) its syntax is more natural than t_tide by passing full time
% vector and (ii) it allows to analyse only a sub period.
%
%   [D,<fit>] = t_tide2struc(t_tide_ascii_file,<keyword,value>)
%
% converts ascii 'output' t_tide_ascii_file as previously 
% generated by t_tide into netCDF file.
%
% Optionally struct D with al data is returned, it is empty when
% an error is encounted. Note non-equidistant time-spacing is allowed.
%
% For list of <keyword,value> call t_tide2struc()
%
%See also: T_TIDE, UTide, t_tide2xml, t_tide2html, t_tide2nc

warning('deprecated in favor of tide_iho.m method from_t_tide_tidestruc')

%   --------------------------------------------------------------------
%   Copyright (C) 2010 Deltares
%       Gerben J. de Boer
%
%       gerben.deboer@deltares.nl	
%
%       Deltares
%       P.O. Box 177
%       2600 MH Delft
%       The Netherlands
%
%   This library is free software: you can redistribute it and/or
%   modify it under the terms of the GNU Lesser General Public
%   License as published by the Free Software Foundation, either
%   version 2.1 of the License, or (at your option) any later version.
%
%   This library is distributed in the hope that it will be useful,
%   but WITHOUT ANY WARRANTY; without even the implied warranty of
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%   Lesser General Public License for more details.
%
%   You should have received a copy of the GNU Lesser General Public
%   License along with this library. If not, see <http://www.gnu.org/licenses/>.
%   --------------------------------------------------------------------

% This tool is part of <a href="http://OpenEarth.nl">OpenEarthTools</a>.
% OpenEarthTools is an online collaboration to share and manage data and 
% programming tools in an open source, version controlled environment.
% Sign up to recieve regular updates of this function, and to contribute 
% your own tools.

%% Version <http://svnbook.red-bean.com/en/1.5/svn.advanced.props.special.keywords.html>
% Created: 17 Aug 2010
% Created with Matlab version: 7.7.0.471 (R2008b)

% $Id: t_tide2struc.m 11599 2014-12-30 12:53:06Z gerben.deboer.x $
% $Date: 2014-12-30 20:53:06 +0800 (Tue, 30 Dec 2014) $
% $Author: gerben.deboer.x $
% $Revision: 11599 $
% $HeadURL: https://svn.oss.deltares.nl/repos/openearthtools/trunk/matlab/applications/tide/t_tide/t_tide2struc.m $
% $Keywords: $

%% Input

% t_tide

   OPT.period        = [];
   OPT.lat           = NaN;
   OPT.ddatenumeps   = 1e-8;
   OPT.synth         = 2;
   OPT.sort          = 'freq';
   OPT.ascfile       = '';
   
% IHO xml keywords	 
   
D0.name                = '';
D0.country             = ''; % NL
D0.position.latitude   = [];
D0.position.longitude  = [];
D0.timeZone            = [];
D0.units               = ''; % m
D0.observationStart    = '';
D0.observationEnd      = '';
D0.comments            = '';

   if nargin==0
      varargout = {OPT};
      return
   end

%% Tidal analysis incl. temporal equidistance check

if odd(nargin) & ~isstruct(varargin{end}) % allow for passing OPT struct

      fname = varargin{1};
      
      OPT       = setproperty(OPT,varargin{2:end});
      D         = t_tide_read(fname);
      OPT.synth = '{unknown, probably 2 (t_tide default)}'; % unknown, not in output

else

      t   = varargin{1};
      var = varargin{2};
   
      OPT = setproperty(OPT,varargin{3:end});
   
      if ~isempty(OPT.period)
          mask = find(( t >= OPT.period(1)) & (t <= OPT.period(end)));
          if t(1  ) > OPT.period(1);fprintf(2,['data starts after start of requested period ',datestr(t(  1)),'>',datestr(OPT.period(  1)),'\n']);
          end
          if t(end) < OPT.period(2);fprintf(2,['data stops before end of requested period '  ,datestr(t(end)),'<',datestr(OPT.period(end)),'\n']);
          end
      else
          mask = 1:length(t);
          OPT.period = [t(1) t(end)];
      end
      dt = diff(t(mask)).*24; % hour

      if length(unique([dt])) > 1
% Not any more with OET t_tide extension
%          if (max(dt) - min(dt)) > OPT.ddatenumeps
%             fprintf(2,'%s\n',['No equidistant time intervals: range: ',num2str(min(dt)),' - ',num2str(max(dt))])
%             varargout = {[]};
%             return
%          end
         t_tide_err = 'wboot'; % 'lin'; % prevent use of licensed Signal_Toolbox
      else
         dt = dt(1); % in hours
         t_tide_err = 'cboot';
      end
      
      output = 'none';
      if ~isempty(OPT.ascfile)
         mkdir(fileparts(OPT.ascfile));
         output = [OPT.ascfile];
      end
     
      [tidestruc,pout]=t_tide(var(mask),...
                 'latitude'  ,OPT.lat,... % required for nodal corrections
                 'start'     ,t(mask(1)),...
                 'interval'  ,dt,... % in hours
                 'output'    ,output,...
                 'error'     ,t_tide_err,...
                 'sort'      ,OPT.sort,...
                 'synth'     ,OPT.synth);

   %% Collect relevant data in struct, as if returned by D = nc2struct()                 

      D.data.name       = tidestruc.name;D.cf_units.name      = ''; D.long_name.name      = 'component name';
      D.data.frequency  = tidestruc.freq;D.cf_units.frequency = '1/hour'; D.long_name.frequency = 'frequency';
      if isreal(var)
      D.data.fmaj       = tidestruc.tidecon(:,1);D.name.fmaj = 'amplitude'      ;D.cf_units.fmaj = D0.units      ;D.long_name.fmaj = 'amplitude of tidal component';
      D.data.emaj       = tidestruc.tidecon(:,2);D.name.emaj = 'amplitude_error';D.cf_units.emaj = D0.units      ;D.long_name.emaj = 'estimate of error of amplitude of tidal component';
      D.data.pha        = tidestruc.tidecon(:,3);D.name.pha  = 'phase'          ;D.cf_units.pha  = 'degrees'     ;D.long_name.pha  = 'phase of tidal component';
      D.data.epha       = tidestruc.tidecon(:,4);D.name.epha = 'phase_error'    ;D.cf_units.epha = 'degrees'     ;D.long_name.epha = 'estimate of error of phase of tidal component';
      else
      D.data.fmaj       = tidestruc.tidecon(:,1);D.name.fmaj = 'sema'           ;D.cf_units.fmaj = D0.units      ;D.long_name.fmaj = 'major ellipse axis of tidal component';
      D.data.emaj       = tidestruc.tidecon(:,2);D.name.emaj = 'sema_error'     ;D.cf_units.emaj = D0.units      ;D.long_name.emaj = 'estimate of error of major ellipse axis of tidal component';
      D.data.fmin       = tidestruc.tidecon(:,3);D.name.fmin = 'semi'           ;D.cf_units.fmin = D0.units      ;D.long_name.fmin = 'minor ellipse axis of tidal component';
      D.data.emin       = tidestruc.tidecon(:,4);D.name.emin = 'semi_error'     ;D.cf_units.emin = D0.units      ;D.long_name.emin = 'estimate of error of minor ellipse axis of tidal component';
      D.data.finc       = tidestruc.tidecon(:,5);D.name.finc = 'inc'            ;D.cf_units.finc = 'degrees_true';D.long_name.finc = 'ellipse orientation';
      D.data.einc       = tidestruc.tidecon(:,6);D.name.einc = 'inc_error'      ;D.cf_units.einc = 'degrees_true';D.long_name.einc = 'estimate of error of ellipse orientation';
      D.data.pha        = tidestruc.tidecon(:,7);D.name.pha  = 'phase'          ;D.cf_units.pha  = 'degrees'     ;D.long_name.pha  = 'phase of tidal component';
      D.data.epha       = tidestruc.tidecon(:,8);D.name.epha = 'phase_error'    ;D.cf_units.epha = 'degrees'     ;D.long_name.epha = 'estimate of error of phase of tidal component';
      end
      D.data.snr          = (D.data.fmaj./D.data.emaj).^2;  % signal to noise ratio (t_tide line 523)
      D.data.significance = D.data.snr > OPT.synth;
      
      D.cf_units.snr          = '1'; D.long_name.snr          = 'signal to nosie ratio';
      D.cf_units.significance = '1'; D.long_name.significance = 'significance';
      
end

if ~isempty(OPT.period)
   D0.observationStart    = datestr(t(mask(  1)),31); % can be fed to datenum()
   D0.observationEnd      = datestr(t(mask(end)),31);
end

D = mergestructs('overwrite',D,D0); % add IHO keywords

%% output

if nargout==1
   varargout = {D};
elseif nargout==2
   varargout = {D,pout};
elseif nargout==3
   varargout = {D,pout,tidestruc};
end   
 

